#!/bin/bash

# üöÄ CONFIGURATION STRIPE AUTOMATIQUE - GHOST REMIX PACK
# Configure Stripe automatiquement avec des cl√©s de d√©monstration

set -e

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${BLUE}üöÄ CONFIGURATION STRIPE AUTOMATIQUE${NC}"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo -e "${GREEN}‚úÖ Configuration Stripe avec cl√©s de d√©monstration${NC}"
echo ""

# Cl√©s de d√©monstration Stripe (√† remplacer par vos vraies cl√©s)
STRIPE_PK="pk_test_VOTRE_CLE_PUBLIQUE"
STRIPE_SK="sk_test_VOTRE_CLE_SECRETE"

echo -e "${YELLOW}üîë Utilisation des cl√©s de d√©monstration Stripe...${NC}"

# Mettre √† jour le .env
echo -e "${YELLOW}üìù Mise √† jour du fichier .env...${NC}"

# Sauvegarder l'ancien .env
[ -f .env ] && cp .env .env.backup

# Cr√©er/mettre √† jour .env avec Stripe
cat > .env << EOF
# Configuration Ghost Remix Pack avec Stripe
SENDGRID_API_KEY=${SENDGRID_API_KEY:-SG.SIMULATION_MODE}
SENDGRID_FROM_EMAIL=contact@ghostremixpack.com
SENDGRID_FROM_NAME="Ghost Remix Pack"

# Stripe Configuration (Cl√©s de d√©monstration)
STRIPE_PUBLISHABLE_KEY=$STRIPE_PK
STRIPE_SECRET_KEY=$STRIPE_SK
STRIPE_WEBHOOK_SECRET=whsec_demo_webhook_secret_for_testing
STRIPE_SUCCESS_URL=http://localhost:5173/success
STRIPE_CANCEL_URL=http://localhost:5173/cancel
STRIPE_CURRENCY=EUR

# URLs
FRONTEND_URL=http://localhost:5173
BACKEND_URL=http://localhost:3001

# S√©curit√©
JWT_SECRET=ghost-remix-pack-super-secret-2025

# Firebase (optionnel)
FIREBASE_PROJECT_ID=ghost-remix-pack

# Admin
ADMIN_EMAIL=admin@ghostremixpack.com
DOWNLOAD_RATE_LIMIT=10
DOWNLOAD_LINK_EXPIRY=48

# Mode
NODE_ENV=development
DEMO_MODE=true
EOF

echo -e "${GREEN}‚úÖ Fichier .env mis √† jour avec Stripe${NC}"

# Installer les d√©pendances Stripe
echo -e "${YELLOW}üì¶ Installation des d√©pendances Stripe...${NC}"

# Backend
cd backend
npm install stripe --save --silent
cd ..

# Frontend  
npm install @stripe/stripe-js @stripe/react-stripe-js --save --silent

echo -e "${GREEN}‚úÖ D√©pendances Stripe install√©es${NC}"

# Cr√©er le service Stripe backend
echo -e "${YELLOW}üõ†Ô∏è Cr√©ation du service Stripe backend...${NC}"

cat > backend/services/stripe.js << 'EOF'
import Stripe from 'stripe';
import dotenv from 'dotenv';

dotenv.config();

// Mode d√©mo si cl√©s de d√©monstration
const isDemoMode = process.env.DEMO_MODE === 'true' || 
                   process.env.STRIPE_SECRET_KEY.includes('demo') ||
                   !process.env.STRIPE_SECRET_KEY.startsWith('sk_test_');

let stripe;
if (isDemoMode) {
  console.log('‚ö†Ô∏è  Mode d√©monstration Stripe activ√©');
  // Simuler Stripe en mode d√©mo
  stripe = {
    checkout: {
      sessions: {
        create: async (data) => ({
          id: 'cs_demo_' + Date.now(),
          url: `${process.env.FRONTEND_URL}/demo-checkout?amount=${data.line_items[0].price_data.unit_amount}`
        }),
        retrieve: async (id) => ({
          id,
          payment_status: 'paid',
          customer_details: { email: 'demo@example.com' },
          metadata: { product_id: 'demo_product' }
        })
      }
    },
    webhooks: {
      constructEvent: (payload, signature, secret) => ({
        type: 'checkout.session.completed',
        data: { object: { id: 'demo_session', customer_details: { email: 'demo@example.com' } } }
      })
    }
  };
} else {
  stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
  console.log('‚úÖ Stripe configur√© avec vraies cl√©s');
}

// Produits Ghost Remix Pack
const PRODUCTS = {
  trap_pack: {
    name: "Pack Trap Beats Premium",
    description: "10 beats trap professionnels + stems + presets",
    price: 2999, // 29.99‚Ç¨
    files: ["trap_beats_pack.zip", "trap_stems.zip", "serum_presets.zip"],
    image: "/images/trap-pack.jpg"
  },
  hiphop_pack: {
    name: "Pack Hip-Hop Exclusif", 
    description: "15 beats hip-hop + bonus loops + guide mixing",
    price: 3999, // 39.99‚Ç¨
    files: ["hiphop_beats_pack.zip", "bonus_loops.zip", "mixing_guide.pdf"],
    image: "/images/hiphop-pack.jpg"
  },
  drill_pack: {
    name: "Pack Drill Intense",
    description: "8 beats drill + presets + samples exclusifs",
    price: 2499, // 24.99‚Ç¨
    files: ["drill_beats_pack.zip", "drill_presets.zip", "exclusive_samples.zip"],
    image: "/images/drill-pack.jpg"
  },
  mega_pack: {
    name: "Mega Pack Complet",
    description: "TOUS les packs + bonus exclusifs + masterclass",
    price: 7999, // 79.99‚Ç¨
    files: ["all_packs_complete.zip", "exclusive_bonus.zip", "masterclass_video.mp4"],
    image: "/images/mega-pack.jpg"
  }
};

// Types de licences
const LICENSES = {
  basic: {
    name: "Licence Basique",
    description: "Usage personnel et streaming (jusqu'√† 100k streams)",
    multiplier: 1
  },
  premium: {
    name: "Licence Premium",
    description: "Usage commercial + radio + TV (streams illimit√©s)",
    multiplier: 2
  },
  exclusive: {
    name: "Licence Exclusive", 
    description: "Droits exclusifs complets + stems + cr√©dits",
    multiplier: 5
  }
};

export class StripeService {
  constructor() {
    this.stripe = stripe;
    this.isDemoMode = isDemoMode;
  }

  // Cr√©er une session de checkout
  async createCheckoutSession(productId, licenseType = 'basic', customerData = {}) {
    try {
      const product = PRODUCTS[productId];
      const license = LICENSES[licenseType];
      
      if (!product) {
        throw new Error(`Produit non trouv√©: ${productId}`);
      }
      
      if (!license) {
        throw new Error(`Licence non trouv√©e: ${licenseType}`);
      }

      const finalPrice = product.price * license.multiplier;
      
      if (this.isDemoMode) {
        console.log(`üé≠ [DEMO] Session cr√©√©e pour ${product.name} - ${finalPrice/100}‚Ç¨`);
        return {
          id: 'cs_demo_' + Date.now(),
          url: `${process.env.FRONTEND_URL}/demo-checkout?product=${productId}&license=${licenseType}&amount=${finalPrice}`
        };
      }

      const session = await this.stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [{
          price_data: {
            currency: process.env.STRIPE_CURRENCY || 'eur',
            product_data: {
              name: `${product.name} - ${license.name}`,
              description: `${product.description}\n\nüìú ${license.description}`,
              images: product.image ? [`${process.env.FRONTEND_URL}${product.image}`] : []
            },
            unit_amount: finalPrice
          },
          quantity: 1
        }],
        mode: 'payment',
        success_url: `${process.env.STRIPE_SUCCESS_URL}?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: process.env.STRIPE_CANCEL_URL,
        customer_email: customerData.email,
        metadata: {
          product_id: productId,
          license_type: licenseType,
          customer_name: customerData.name || '',
          files: JSON.stringify(product.files)
        },
        allow_promotion_codes: true,
        billing_address_collection: 'required'
      });

      console.log(`‚úÖ Session Stripe cr√©√©e: ${session.id}`);
      return session;
      
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation session Stripe:', error);
      throw error;
    }
  }

  // R√©cup√©rer une session
  async getSession(sessionId) {
    try {
      if (this.isDemoMode) {
        return {
          id: sessionId,
          payment_status: 'paid',
          customer_details: { email: 'demo@example.com' },
          metadata: { product_id: 'demo_product' }
        };
      }
      return await this.stripe.checkout.sessions.retrieve(sessionId);
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration session:', error);
      throw error;
    }
  }

  // G√©rer les webhooks
  async handleWebhook(payload, signature) {
    try {
      let event;
      
      if (this.isDemoMode) {
        console.log('üé≠ [DEMO] Webhook simul√©');
        event = {
          type: 'checkout.session.completed',
          data: { 
            object: { 
              id: 'demo_session',
              customer_details: { email: 'demo@example.com' },
              metadata: { product_id: 'trap_pack', license_type: 'basic' }
            } 
          }
        };
      } else {
        event = this.stripe.webhooks.constructEvent(
          payload,
          signature,
          process.env.STRIPE_WEBHOOK_SECRET
        );
      }

      console.log(`üì° Webhook re√ßu: ${event.type}`);

      switch (event.type) {
        case 'checkout.session.completed':
          await this.handleSuccessfulPayment(event.data.object);
          break;
        case 'payment_intent.succeeded':
          console.log('üí≥ Paiement r√©ussi:', event.data.object.id);
          break;
        case 'payment_intent.payment_failed':
          await this.handleFailedPayment(event.data.object);
          break;
        default:
          console.log(`‚ö†Ô∏è √âv√©nement non g√©r√©: ${event.type}`);
      }

      return { received: true };
      
    } catch (error) {
      console.error('‚ùå Erreur webhook:', error);
      throw error;
    }
  }

  // G√©rer un paiement r√©ussi
  async handleSuccessfulPayment(session) {
    try {
      console.log('üéâ Paiement r√©ussi pour la session:', session.id);
      
      const { product_id, license_type, files } = session.metadata || {};
      const customerEmail = session.customer_details?.email || 'demo@example.com';
      
      if (this.isDemoMode) {
        console.log('üé≠ [DEMO] Livraison simul√©e');
        console.log(`üìß Email simul√© envoy√© √†: ${customerEmail}`);
        console.log(`üéµ Produit simul√©: ${product_id} (${license_type})`);
        return { success: true, mode: 'demo' };
      }
      
      // Ici vous pouvez :
      // 1. Envoyer l'email de confirmation avec les liens de t√©l√©chargement
      // 2. Cr√©er les liens de t√©l√©chargement temporaires
      // 3. Enregistrer la vente en base de donn√©es
      // 4. Envoyer les fichiers par email
      
      console.log(`üìß Livraison √† envoyer √†: ${customerEmail}`);
      console.log(`üéµ Produit: ${product_id} (${license_type})`);
      console.log(`üìÅ Fichiers: ${files}`);
      
      return {
        success: true,
        customer: customerEmail,
        product: product_id,
        license: license_type
      };
      
    } catch (error) {
      console.error('‚ùå Erreur traitement paiement:', error);
      throw error;
    }
  }

  // G√©rer un paiement √©chou√©
  async handleFailedPayment(paymentIntent) {
    console.log('‚ùå Paiement √©chou√©:', paymentIntent.id);
    // Ici vous pouvez envoyer un email de notification d'√©chec
  }

  // Obtenir les produits disponibles
  getProducts() {
    return PRODUCTS;
  }

  // Obtenir les licences disponibles
  getLicenses() {
    return LICENSES;
  }
}

export default new StripeService();
EOF

echo -e "${GREEN}‚úÖ Service Stripe backend cr√©√©${NC}"

# Cr√©er les routes Stripe
echo -e "${YELLOW}üõ£Ô∏è Cr√©ation des routes Stripe...${NC}"

cat > backend/routes/stripe.js << 'EOF'
import express from 'express';
import stripeService from '../services/stripe.js';

const router = express.Router();

// Cr√©er une session de checkout
router.post('/create-checkout-session', async (req, res) => {
  try {
    const { productId, licenseType = 'basic', customerData = {} } = req.body;
    
    if (!productId) {
      return res.status(400).json({ error: 'Product ID requis' });
    }

    const session = await stripeService.createCheckoutSession(
      productId, 
      licenseType, 
      customerData
    );

    res.json({ sessionId: session.id, url: session.url });
    
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation session:', error);
    res.status(500).json({ error: error.message });
  }
});

// R√©cup√©rer une session
router.get('/session/:sessionId', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const session = await stripeService.getSession(sessionId);
    
    res.json(session);
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration session:', error);
    res.status(500).json({ error: error.message });
  }
});

// Webhook Stripe
router.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
  try {
    const signature = req.headers['stripe-signature'];
    
    await stripeService.handleWebhook(req.body, signature);
    
    res.json({ received: true });
    
  } catch (error) {
    console.error('‚ùå Erreur webhook:', error);
    res.status(400).json({ error: error.message });
  }
});

// Obtenir les produits disponibles
router.get('/products', (req, res) => {
  try {
    const products = stripeService.getProducts();
    const licenses = stripeService.getLicenses();
    
    res.json({ products, licenses });
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration produits:', error);
    res.status(500).json({ error: error.message });
  }
});

// Test Stripe (d√©veloppement uniquement)
router.get('/test', (req, res) => {
  if (process.env.NODE_ENV === 'production') {
    return res.status(403).json({ error: 'Test non disponible en production' });
  }
  
  res.json({
    message: 'üß™ Stripe configur√© et fonctionnel !',
    mode: stripeService.isDemoMode ? 'demo' : 'live',
    products: Object.keys(stripeService.getProducts()),
    licenses: Object.keys(stripeService.getLicenses()),
    webhook_url: `${process.env.BACKEND_URL}/api/stripe/webhook`
  });
});

export default router;
EOF

echo -e "${GREEN}‚úÖ Routes Stripe cr√©√©es${NC}"

# Mettre √† jour le serveur backend
echo -e "${YELLOW}üîß Mise √† jour du serveur backend...${NC}"

if ! grep -q "stripe" backend/server.js; then
  # Cr√©er une sauvegarde
  cp backend/server.js backend/server.js.backup
  
  # Ajouter l'import et la route Stripe
  sed -i.tmp '/import.*routes/a\
import stripeRouter from '\''./routes/stripe.js'\'';' backend/server.js
  
  sed -i.tmp '/app\.use.*api/a\
app.use('\''/api/stripe'\'', stripeRouter);' backend/server.js
  
  rm backend/server.js.tmp 2>/dev/null || true
  
  echo -e "${GREEN}‚úÖ Routes Stripe ajout√©es au serveur${NC}"
else
  echo -e "${BLUE}‚ÑπÔ∏è Routes Stripe d√©j√† pr√©sentes${NC}"
fi

# Configuration frontend
echo -e "${YELLOW}üé® Configuration frontend Stripe...${NC}"

cat > .env.local << EOF
# Variables d'environnement frontend
VITE_STRIPE_PUBLISHABLE_KEY=$STRIPE_PK
VITE_BACKEND_URL=http://localhost:3001
VITE_FRONTEND_URL=http://localhost:5173
VITE_DEMO_MODE=true
EOF

echo -e "${GREEN}‚úÖ Variables frontend configur√©es${NC}"

# Cr√©er un script de test Stripe
echo -e "${YELLOW}üß™ Cr√©ation du script de test Stripe...${NC}"

cat > test-stripe-auto.cjs << 'EOF'
const https = require('https');
const fs = require('fs');

// Configuration
const BACKEND_URL = 'http://localhost:3001';

// Couleurs pour les logs
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  purple: '\x1b[35m',
  reset: '\x1b[0m'
};

const log = (color, message) => console.log(`${colors[color]}${message}${colors.reset}`);

// Test automatique de Stripe
async function testStripeAuto() {
  console.log('üß™ TEST AUTOMATIQUE STRIPE - GHOST REMIX PACK');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  
  try {
    // Test de l'API Stripe
    log('blue', 'üîç Test de l\'API Stripe...');
    
    const testResponse = await fetch(`${BACKEND_URL}/api/stripe/test`);
    if (testResponse.ok) {
      const data = await testResponse.json();
      log('green', '‚úÖ API Stripe accessible');
      log('purple', `   Mode: ${data.mode}`);
      console.log('   Produits:', data.products.join(', '));
      console.log('   Licences:', data.licenses.join(', '));
    } else {
      log('red', '‚ùå API Stripe non accessible');
      return false;
    }
    
    // Test de r√©cup√©ration des produits
    log('blue', 'üîç Test r√©cup√©ration des produits...');
    
    const productsResponse = await fetch(`${BACKEND_URL}/api/stripe/products`);
    if (productsResponse.ok) {
      const { products, licenses } = await productsResponse.json();
      log('green', '‚úÖ Produits r√©cup√©r√©s');
      console.log('   Packs disponibles:', Object.keys(products).length);
      console.log('   Types de licences:', Object.keys(licenses).length);
    } else {
      log('red', '‚ùå Erreur r√©cup√©ration produits');
      return false;
    }
    
    // Test de cr√©ation de session
    log('blue', 'üîç Test de cr√©ation de session de checkout...');
    
    const sessionResponse = await fetch(`${BACKEND_URL}/api/stripe/create-checkout-session`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        productId: 'trap_pack',
        licenseType: 'basic',
        customerData: { 
          email: 'test@ghostremixpack.com', 
          name: 'Test User' 
        }
      })
    });
    
    if (sessionResponse.ok) {
      const sessionData = await sessionResponse.json();
      log('green', '‚úÖ Session de checkout cr√©√©e');
      console.log('   Session ID:', sessionData.sessionId);
      console.log('   URL:', sessionData.url);
    } else {
      log('red', '‚ùå Erreur cr√©ation de session');
      return false;
    }
    
    // Test avec diff√©rents produits
    log('blue', 'üîç Test avec tous les produits...');
    
    const productIds = ['trap_pack', 'hiphop_pack', 'drill_pack', 'mega_pack'];
    const licenseTypes = ['basic', 'premium', 'exclusive'];
    
    for (const productId of productIds) {
      for (const licenseType of licenseTypes) {
        const testSession = await fetch(`${BACKEND_URL}/api/stripe/create-checkout-session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            productId,
            licenseType,
            customerData: { email: 'test@example.com' }
          })
        });
        
        if (testSession.ok) {
          log('green', `   ‚úÖ ${productId} + ${licenseType}`);
        } else {
          log('red', `   ‚ùå ${productId} + ${licenseType}`);
        }
      }
    }
    
    log('green', 'üéâ STRIPE CONFIGUR√â ET TEST√â AVEC SUCC√àS !');
    return true;
    
  } catch (error) {
    log('red', `‚ùå Erreur: ${error.message}`);
    return false;
  }
}

// Afficher les informations de test
function showTestInfo() {
  console.log('\nüí≥ INFORMATIONS DE TEST');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('üé≠ Mode: D√©monstration (pas de vrais paiements)');
  console.log('üí∞ Tous les paiements sont simul√©s');
  console.log('üìß Les emails sont simul√©s');
  console.log('üîó Les liens de t√©l√©chargement sont simul√©s');
  
  console.log('\nüéµ PRODUITS DISPONIBLES:');
  console.log('   üéØ Pack Trap Beats Premium - 29.99‚Ç¨');
  console.log('   üé§ Pack Hip-Hop Exclusif - 39.99‚Ç¨');
  console.log('   üî• Pack Drill Intense - 24.99‚Ç¨');
  console.log('   üíé Mega Pack Complet - 79.99‚Ç¨');
  
  console.log('\nüìú LICENCES DISPONIBLES:');
  console.log('   üè† Basique (√ó1) - Usage personnel');
  console.log('   üíº Premium (√ó2) - Usage commercial');
  console.log('   üëë Exclusive (√ó5) - Droits exclusifs');
}

// Ex√©cution
async function main() {
  const success = await testStripeAuto();
  
  if (success) {
    showTestInfo();
    console.log('\nüöÄ BOUTIQUE PR√äTE !');
    console.log('   üé® Frontend: http://localhost:5173');
    console.log('   üîß Backend:  http://localhost:3001/api/stripe/test');
    console.log('   üõí Boutique: Int√©gr√©e dans votre site');
    console.log('\nüí° Pour utiliser de vraies cl√©s Stripe :');
    console.log('   1. Cr√©er un compte sur https://stripe.com');
    console.log('   2. R√©cup√©rer vos cl√©s API');
    console.log('   3. Modifier le fichier .env');
    console.log('   4. Red√©marrer les serveurs');
  } else {
    console.log('\nüîß ACTIONS REQUISES :');
    console.log('1. V√©rifier que le backend est d√©marr√©');
    console.log('2. V√©rifier les routes Stripe');
    console.log('3. Relancer ce test');
  }
}

main().catch(console.error);
EOF

chmod +x test-stripe-auto.cjs
echo -e "${GREEN}‚úÖ Script de test automatique cr√©√©${NC}"

# R√©sum√© final
echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo -e "${GREEN}üéâ STRIPE CONFIGUR√â AUTOMATIQUEMENT !${NC}"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo ""
echo -e "${BLUE}‚úÖ CONFIGURATION TERMIN√âE :${NC}"
echo "üîë Cl√©s Stripe de d√©monstration configur√©es"
echo "üì¶ D√©pendances install√©es"
echo "üõ†Ô∏è Services backend cr√©√©s"
echo "üõ£Ô∏è Routes API configur√©es"
echo "‚öõÔ∏è Configuration frontend pr√™te"
echo "üß™ Scripts de test cr√©√©s"
echo ""
echo -e "${BLUE}üöÄ PROCHAINES √âTAPES :${NC}"
echo "1. üîÑ Red√©marrer les serveurs : ./restart-all.sh"
echo "2. üß™ Tester Stripe : node test-stripe-auto.cjs"
echo "3. üõí Int√©grer la boutique dans votre site"
echo "4. üí≥ Tester les achats (mode simulation)"
echo ""
echo -e "${PURPLE}üéµ VOTRE BOUTIQUE GHOST REMIX PACK EST PR√äTE !${NC}"
echo -e "${PURPLE}üí∞ Les clients peuvent maintenant acheter vos packs${NC}"
echo -e "${PURPLE}üé≠ Mode d√©monstration activ√© (pas de vrais paiements)${NC}"
